[{"title":"Windows 编程学习笔记 01","path":"/2024/06/01/Windows 编程学习笔记 01/","content":"0x01 准备工作VS2022 &amp; C++ 新建空项目并设置 项目属性-&gt;链接器-&gt;系统-&gt;子系统 为 窗口 遇到不确定用法的函数，可以选中并按 F1 0x02 Windows 常见的数据类型UINT 无符号32位整型DTORD 32位整数PDWORD 32位整数类型指针。BOOL 布尔类型SHORT 带符号16位整数。LRESULT 32位函数返回值TPARAM 32位的消息参数。LPARAM 32位的消息参数。HANDLE 是 Windows 编程中一个特别重要的概念，在计算机中翻译为句柄。用于标示操作系统中的某个对象。HANDLE 通用句柄HWND 窗口句柄HINSTANCE 实例句柄LPSTR 字符串指针 0x03 一个简单的 HelloWorld1234567891011#include&lt;Windows.h&gt;int WINAPI WinMain( // 这是程序入口，类似原本的 main\tHINSTANCE hInstance, // 程序实例句柄\tHINSTANCE hPreHinstance, // 上一个程序实例句柄(已弃用)\tLPSTR lpCmdeLine, // 传入参数，类似arg[]\tint nCmdeShow // 显示方式)&#123; MessageBoxA(NULL,&quot;HelloWorld!&quot;,&quot;标题&quot;,MB_OKCANCEL);// A(ANSI)，W(Unicode)\t// 关于窗口返回值可以按F1去看手册 return 0;&#125; 0x04 Windows 字符串C++ 支持两种字符串，ANSI 编码(使用””包裹)和 Unicode 编码(使用L””包裹) 普通字符串类型 CHAR，即 char，多字节字符集类型 宽字符串类型 WCHAR，即 wchar_t，Unicode 类型，输出使用 %ls 通用字符串类型 TCHAR，类型未知，由环境决定，需要引入 tchar.h 头文件。环境设置可见 项目属性-&gt;高级-&gt;字符集 微软将其通过条件编译进行统一（通过 _UNICODE 和 UNICODE 宏 ），于是有了_T(&quot;&quot;) 这样的字符串 常用字符串处理函数分三种系列：str, wcs, _tcs 长度计算：strlen, wcslen, _tcslen 字符串转数字： A 版本：atoi, strtol W 版本：_wtoi, wcstol T 版本：_ttoi, _tcstol 数字到字符串： A 版本：_itoa_s, itoa（不安全） W 版本：_itow_s T 版本：_itot_s 两者相互转换（建议定义一个宏）： W 到 A 的转换：WideCharToMultiByte() A 到 W 的转换：MultiByteToWideChar() 0x05 第一个窗口程序写一个窗口程序需要四步：创建窗口类，注册窗口类，创建窗口实例，显示窗口 首先使用 WNDCLASSW 创建一个窗口类，关于它的参数： 123456789101112typedef struct tagWNDCLASSW &#123; UINT style; // 样式 WNDPROC lpfnWndProc; // 回调函数 *这项必须有 int cbClsExtra; // 0 int cbWndExtra; // 0 HINSTANCE hInstance; // 程序的实例句柄 HICON hIcon; // 程序图标 HCURSOR hCursor; // 光标 HBRUSH hbrBackground; // 背景画刷 LPCWSTR lpszMenuName; // 菜单名称 LPCWSTR lpszClassName; // 程序类名 *这项必须有&#125; WNDCLASSW, *PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW; 于是写作： 1234// 1.创建一个窗口类\tWNDCLASSW myclass = &#123; 0 &#125;;\tmyclass.lpszClassName = L&quot;windowClassTry&quot;; // 定义类名\tmyclass.lpfnWndProc = nullptr; // 回调函数,先设置为无，之后修改 当然，这里还有其他版本的创建函数，类似操作。 注册窗口类：一个类名只能注册一次 1RegisterClassW(&amp;myclass); 使用 CreateWindowW 创建窗口实例，关于它的参数： 12345678910111213HWND CreateWindowW( [in, optional] lpClassName, // 程序类名 [in, optional] lpWindowName, // 窗口名称 [in] dwStyle, // 窗口样式，例如WS_OVERLAPPEDWINDOW，可按F12快速查看 [in] x, // 坐标，可以使用 CW_USEDEFAULT 用户默认 [in] y, // x使用默认后可设置为0 [in] nWidth, // 宽，可设置默认 CW_USEDEFAULT [in] nHeight, // 使用默认后可设置为0 [in, optional] hWndParent, // 父窗口句柄，没有则为NULL [in, optional] hMenu, [in, optional] hInstance, [in, optional] lpParam // 回调参数，没有则可设置为0); 于是写作 1234567891011121314// 3.创建窗口实例\tHWND hwindow = CreateWindowW( myclass.lpszClassName, L&quot;窗口名称&quot;, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, 0\t); 使用 ShowWindow 显示窗口 它只有两个参数，窗口句柄和显示样式(SW_开头，F12可查)，这里写作 12// 4.显示窗口\tShowWindow(hwindow, SW_SHOWNORMAL); 编译运行，程序发生异常，原因是原本创建窗口类时的回调函数使用了空指针，需要进行修改。对 WNDCLASSW 按 F1 可查找到 lpfnWndProc 必须使用 CallWindowProc 函数调用窗口过程。 有关详细信息，请参阅 WindowProc。于是找到 1234567LRESULT Wndproc(\tHWND hwnd,\tUINT uMsg,\tWPARAM wParam,\tLPARAM lParam)&#123;...&#125; 直接将函数内容设置为 return 0，完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041LRESULT Wndproc(\tHWND hwnd,\tUINT uMsg,\tWPARAM wParam,\tLPARAM lParam)&#123;\treturn 0;&#125;int WINAPI WinMain(\tHINSTANCE hInstance, // 程序实例句柄\tHINSTANCE hPreHinstance, // 上一个程序实例句柄(已弃用)\tLPSTR lpCmdeLine, // 传入参数，类似arg[]\tint nCmdeShow // 显示方式) &#123;\t// 1.创建一个窗口类\tWNDCLASSW myclass = &#123; 0 &#125;;\tmyclass.lpszClassName = L&quot;windowClassTry&quot;; // 类名\tmyclass.lpfnWndProc = Wndproc; // 回调函数\t// 2.注册窗口类：一个类名只能注册一次\tRegisterClassW(&amp;myclass);\t// 3.创建窗口实例\tHWND hwindow = CreateWindowW( myclass.lpszClassName, L&quot;窗口名称&quot;, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, 0\t);\t// 4.显示窗口\tShowWindow(hwindow, SW_SHOWNORMAL);\treturn 0;&#125; 此时程序没有发生异常，但刚运行便结束。关于如何解决这个问题，需要了解 Windows 的消息机制。 0x06 消息机制初步Windows 系统是基于消息的操作系统。每一个窗口都在不停的处理消息，所有的操作都是接收到消息之后，进行处理的结果。围绕着消息的处理，产生了获取消息的消息泵机制也叫消息循环，以及处理消息的窗口回调函数机制。 Windows 下产生消息的时机共有以下四种: 用户主动产生的消息 Windows 系统本身产生的消息: 应用程序本身产生的消息 其他应用程序产生的消息。 消息的发送与接收 Windows 系统有一个系统消息队列，每个 GUI 程序也有自己的消息队列，系统消息队列负责将消息发送给不同程序的消息队列。 GetMessage：从消息队列中取出消息，关于参数： 123456GetMessageW( _Out_ LPMSG lpMsg, // MSG 类型的消息变量 _In_opt_ HWND hWnd,// 窗口句柄 _In_ UINT wMsgFilterMin, // 获取消息的范围 _In_ UINT wMsgFilterMax);// 获取消息的范围// 后面两个可以都设置为0来获取所有消息 DispatchMessage：将消息发送给处理消息的回调函数 了解到以上知识，可以增加如下消息机制： 123456// 5.获取消息\tMSG msg = &#123; 0 &#125;;\twhile (GetMessageW(&amp;msg,0,0,0))&#123; DispatchMessageW(&amp;msg);// 分发消息\t&#125;// 第二个参数使用 0 表示处理全部程序的消息，以免无法发送最后的程序退出信号 对应地，将原来的回调函数更改为： 123456789101112131415161718192021LRESULT Wndproc(\tHWND hwnd,\tUINT uMsg,\tWPARAM wParam,\tLPARAM lParam)&#123;\tswitch (uMsg)\t&#123;\tcase WM_CREATE: MessageBoxW(hwnd,L&quot;窗口已创建&quot;,L&quot;窗口标题&quot;,MB_OK); break;\tcase WM_CLOSE: MessageBoxW(hwnd, L&quot;窗口已关闭&quot;, L&quot;窗口标题&quot;, MB_OK); DestroyWindow(hwnd); // 销毁窗口 PostQuitMessage(0); // 发送程序退出消息，这里和java的swt类似\tdefault: break;\t&#125;\treturn DefWindowProcW(hwnd, uMsg, wParam, lParam);&#125; 最后我们得到一个可以完整的窗口程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;Windows.h&gt;LRESULT Wndproc(\tHWND hwnd,\tUINT uMsg,\tWPARAM wParam,\tLPARAM lParam)&#123;\tswitch (uMsg)\t&#123;\tcase WM_CREATE: MessageBoxW(hwnd,L&quot;窗口已创建&quot;,L&quot;窗口标题&quot;,MB_OK); break;\tcase WM_CLOSE: MessageBoxW(hwnd, L&quot;窗口已关闭&quot;, L&quot;窗口标题&quot;, MB_OK); DestroyWindow(hwnd); // 销毁窗口 PostQuitMessage(0); // 发送程序退出消息，这里和java的swt类似\tdefault: break;\t&#125;\treturn DefWindowProcW(hwnd, uMsg, wParam, lParam);&#125;int WINAPI WinMain(\tHINSTANCE hInstance, // 程序实例句柄\tHINSTANCE hPreHinstance, // 上一个程序实例句柄(已弃用)\tLPSTR lpCmdeLine, // 传入参数，类似arg[]\tint nCmdeShow // 显示方式) &#123;\t// 1.创建一个窗口类\tWNDCLASSW myclass = &#123; 0 &#125;;\tmyclass.lpszClassName = L&quot;windowClassTry&quot;; // 类名\tmyclass.lpfnWndProc = Wndproc; // 回调函数\t// 2.注册窗口类：一个类名只能注册一次\tRegisterClassW(&amp;myclass);\t// 3.创建窗口实例\tHWND hwindow = CreateWindowW( myclass.lpszClassName, L&quot;窗口名称&quot;, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, 0\t);\t// 4.显示窗口\tShowWindow(hwindow, SW_SHOWNORMAL);\t// 5.获取消息\tMSG msg = &#123; 0 &#125;;\twhile (GetMessageW(&amp;msg,0,0,0))&#123; DispatchMessageW(&amp;msg);// 分发消息\t&#125;\treturn 0;&#125; 注：写最后部分代码时遇到了一点点小坑，代码注释中可见一斑。","tags":["Windows编程 逆向辅助开发"]},{"title":"递归思维：最小生成树的 Prim 算法","path":"/2024/04/03/递归思维：最小生成树的 Prim 算法/","content":"一、什么是递归​\t递归算法的定义是通过重复将问题分解为同类的子问题而解决问题的方法。定义略微抽象，可以简单理解为如果每次调用自身可以将问题简化一点点，并且它的最简单的形式是容易求解的，那么这个问题就可以通过有限次调用自身实现递归求解。这个思路非常类似数学归纳法。 先看一个简单的例子：阶乘，即 ”给定一个正整数 N, 求出 1x2x...xN 的值”。 假定读者对编程有一点了解，那么我们使用递归方式求解的做法如下： 123456int f(int n)&#123; if(n==1) // 如果 n 为 1，返回 1 return 1;\telse // 如果 n 不为 1，返回 n 乘 f(n-1) return n*f(n-1);&#125; 例如 n 为 3，因为 3 不为 1，返回 3*f(2) ; 此时 n 为 2，因为 2 不为 1，返回 2*f(1)，结合刚刚的 3 就是 3*2*f(1) ; 此时 n 为 1，因为 1 等于 1，返回 1，综合以上得到最终结果 3*2*1=6 ; 可能有人会认为使用循环来解决问题可以避免这样抽象的做法，但这只是一个方便理解的简单例子，在更多的时候，递归的算法可以简化问题，达到很好的效果，我相信读者在接下来两个例子中会不断有更加深入的体会。 插入排序：将 N 个数据按从小到大的顺序排列起来，已知数据的移动成本可以忽略。 这里仅说明思路：以现实中扑克牌排序为例，假设前 N-1 张牌已经排好了顺序，那么只需要将第 N 张放到正确的位置，那么第 N-1 张当然是在假定前N-2 张排好顺序的基础上放置的。以此类推，第 2 张是在第 1 张放好的前提下进行的。对于第 1 张，它自身就是已经排好顺序了。 事实上现实中人们取扑克牌的时候一直在使用这种方法，尽管可能没有意识到。 二、最小生成树问题​\t我们跳过图论中比较复杂的概念，给出一个实际问题，现在我们有一个数组保存有 N个点的位置坐标，如何将所有的点连接起来，要求所有线段的长度的和最小。以使用 MATLAB 生成的如图 200 个点为例。 ​\t如果 N 比较小，你当然可以使用穷举法；但在 N 相对较大(事实上只需要稍微大一点点)的情况下，两点之间连接的可能非常多，穷举非常不现实的，如图可见一斑。 三、Prim 算法​\t对于最小生成树问题，可能很多人的第一感觉是无从下手。考虑到我们平时做题时，遇到无法解决的问题，有一个很自然的想法是先试着解决一个更简单的问题，然后看怎么将简单问题的解法推广过来。那么，对于从如何这个 N 个点的最小生成树问题中找到一个更简单的问题呢？很自然的想法是将 N 减 1，考虑 N-1 个点的情形，这与刚刚我们使用递归的方法解决扑克牌插入排序问题的方式不谋而合。 ​\t对的，假设前 k-1 个点已经正确连接，那么我们只需要将第 k 个点连接到这 k-1 个点中离它最近的那个点上。依次递推，对于第一个点，或者说，我们只需要先随便取出来一个点，然后进行刚刚提到的连接操作就可以了。这就是 Prim 算法。 以下给出一个 MATLAB 的简单实现，或许读者可以对它进行优化。 1234567locaTopu=Prim(loca,locaA);for i=1:length(locaTopu) plot([loca(locaTopu(i,1)),loca(locaTopu(i,2))],&quot;.-&quot;); hold onendtitle(&quot;Prim 算法得到的最小生成树&quot;)hold off 12345678910111213141516171819202122232425262728293031function treeTopu =Prim(loca,locaA) % treeTopu需要连接的点的拓扑 loca位置向量 locaA距离矩阵 constFAR=2; function [oldP,minP] = primNewP(treeYes,locaB) % oldP已有点位置 minP新连接点位置 minP=NaN; % 最小点位置 minDist=constFAR; % 最小点距离 oldP=0; for i=treeYes if min(locaB(i,:)) &lt; minDist if min(locaB(i,:))~=constFAR [minDist,minP]=min(locaB(i,:)); oldP=i; end end %disp([minDist,minP]) end end locaB=locaA; locaB(locaB==0)=constFAR; treeTopu=[]; % 最小生成树的拓扑：0不连接，1连接 treeYes=1; % 已经在树中的 treeNo=2:length(loca); % 待排的 locaB(:,1)=constFAR; while(~isempty(treeNo)) [oldP,newP]=primNewP(treeYes,locaB); treeTopu=[treeTopu;oldP,newP]; locaB(:,newP)=constFAR; % 销毁已经使用过的最小值，以免重复 treeYes=[treeYes,newP]; treeNo(find(treeNo==newP,1))=[]; endend 最后可以得到结果如图 注：因为这里面包含了部分笔者的作业内容，为证明作业真实由笔者所做，已将笔者身份包含在了随机数种子中。转载还请注明出处，以免对笔者造成不必要的麻烦。","tags":["算法 图论 MATLAB"]},{"title":"我的 QT 学习记录 02","path":"/2023/10/21/我的QT学习记录02/","content":"一、对象树 对象树，也叫对象模型，是把子类依次绑定到父类，形成的树状结构 对象树是 Qt 简化内存回收的模型，析构一个对象时会先依次递归析构其子对象，然后把自己从 parent 的 children() 里面删除 在栈上可能遇到析构的问题示例，解决方案是建议在堆上进行构造 1234567891011// 该段代码无问题，因为栈一般先构造的后析构// 这里先析构 button，并从 window 的子对象列表中删除// 然后析构 window(此时已经无子对象)Qwidget window;OPushButton button = QPushButton (&quot;退出&quot;，&amp;window);// 该段代码有问题:因为栈一般先构造的后析构，导致重复析构，程序崩溃。// 下面程序是先析构 window，析构 window 及其子对象(quit)，然后析构quitQPushButton quit(&quot;Quit&quot;);Qwidget window;quit.setParent(&amp;window); 二、信号与槽机制 信号槽是 Qt 特色，某个事件发生后，会广播一个信号(signal)，如果有对象需要对这个信号反馈，就会使用连接函数(connect)，即为将要处理的信号与自己的反馈函数(称为槽slot)绑定来处理这个信号。也就是说，信号被发出后，被连接的槽函数会自动被回调，类似观察者模式 连接函数 connect 的使用 基本用法：connect(sender,signal,receiver,slot) 发送者，信号，接收者，槽函数 可以参考帮助手册上需要的类及其父类的 Public Slots 和 Signals 使用预设的信号槽 123456789101112131415// widget.cpp#include &quot;widget.h&quot;#include &lt;QPushButton&gt;Widget::Widget(QWidget *parent) : QWidget(parent)&#123; // 创建按钮 QPushButton *btn=new QPushButton(&quot;点击关闭窗口&quot;,this); this-&gt;resize(600,400); // 绑定信号 connect(btn,&amp;QPushButton::clicked,this,&amp;Widget::close);&#125;Widget::~Widget()&#123;&#125; 自定义信号槽 大致思路 添加信号发送类，接收类 在发送类中声明信号，在接收类中声明并实现槽函数 注意 信号 在头文件的 signals 中声明，返回值 void ，可以有参数，仅声明不实现，可重载 槽函数 在头文件的 public slots 里面声明，需要实现，返回值 void，可以有参数，可重载。对于一些高版本的来说，也可以写到 public 或者全局。 简易示例，借助 QDebug 项目结构 widget.h, widget.cpp, main.cpp, 按照预设 mysender.h, mysender.cpp，继承自 QObject myreceiver.h，myreceiver.cpp, 继承自 QObject 信号与槽的定义实现 mysender.h 添加内容 12signals: // 信号声明\tvoid here_a_signal(); myreceiver.h 添加内容 12public slots: // 槽函数声明 void slots_ok(); myreceiver.cpp 添加内容 12345#include &lt;QDebug&gt; // 槽函数实现void MyReceiver::slots_ok()&#123; qDebug()&lt;&lt;&quot;这是槽函数，已经收到信号&quot;;&#125; 配置与连接 widget.h 12#include &quot;mysender.h&quot;#include &quot;myreceiver.h&quot; 123public: MySender *sdr; MyReceiver *rcvr; widget.cpp 12345// 自定义信号与槽this-&gt;sdr = new MySender();this-&gt;rcvr =new MyReceiver();// 连接信号槽connect(sdr,&amp;MySender::here_a_signal,rcvr,&amp;MyReceiver::slots_ok); 信号产生 widget.h 12pubic:\tvoid signal_generate(); widget.cpp 1234void Widget::signal_generate() // 信号产生函数&#123; emit sdr-&gt;here_a_signal();// 触发信号&#125; 12// 发出信号signal_generate(); 程序现象 12310:01:14: Starting Qtlearning01.exe...&gt;&gt;这是槽函数，已经收到信号10:01:20: Qtlearning01.exe 退出，退出代码: 0 示例更进一步-绑定按钮 方式一，信号触发函数 1connect(button,&amp;QPushButton::clicked,this,&amp;Widget::signal_generate); 方式二，信号连接信号 1connect(button,&amp;QPushButton::clicked,sdr,&amp;MySender::here_a_signal); 槽函数的参数与重载 参考CSDN 在Qt中信号和槽都可以是函数指针，即 &amp;函数名，即可得到函数所在的地址，但是如果遇到重载的函数，如果不区分就会报错。 重载的两种方式 使用 QOverload 1234connect(comboBox, QOverload&lt;int&gt;::of(&amp;QComboBox::activated), [=](int index)&#123; /* ... */ &#125;);connect(comboBox, QOverload&lt;const QString &amp;&gt;::of(&amp;QComboBox::activated), [=](const QString &amp;text)&#123; /* ... */ &#125;); 借助函数指针的思想 123456void (QComboBox:: * activatedInt)(int) = &amp;QComboBox::activated;void (QComboBox:: * activatedString)(QString) = &amp;QComboBox::activated;connect(comboBox, activatedInt, [=](int index)&#123; /* ... */ &#125;);connect(comboBox, activatedString, [=](const QString &amp;text)&#123; /* ... */ &#125;); C++ 补充示例-函数指针遇上函数重载 参考CSDN 确定类型指针 123456789101112131415161718void print(int a)&#123; cout &lt;&lt; &quot;a is &quot; &lt;&lt; a &lt;&lt; endl;&#125;void print()&#123; cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;&#125;typedef void (* Fun)(int);typedef void (* Fun2)();int main()&#123; Fun pPrint = print; Fun2 pPrint2 = print; pPrint(12); pPrint2(); return 0;&#125; 程序运行结果 12&gt;&gt;a is 12&gt;&gt;hello world 非确定类型指针 重载函数作为参数传递时，特别形参的类型不是确定的函数指针类型时，如 void *，例如 Qt 中的QObject::connect() 函数，重载的信号或槽传入到 connect 时，可以使用 static_cast&lt;&gt; 来区别重载函数： 1connect(subWidget, static_cast&lt;void(SubWidget::*)()&gt;(&amp;SubWidget::switchWin), this, &amp;MainWidget::switchWinSlot); 一般方法 示例 重写信号声声明(带参数) 123signals:\tvoid here_a_signal();\tvoid here_a_signal(QString content); 重写槽函数声明与定义(带参数) 123public slots: void slots_ok();\tvoid slots_ok(QString content); 1234void MyReceiver::slots_ok(QString content)&#123; qDebug()&lt;&lt;&quot;这是重载的槽函数，信号内容:&quot;&lt;&lt;content;&#125; 123public:void signal_generate();void signal_generate(QString qstr); 1234void Widget::signal_generate(QString qstr)&#123; emit sdr-&gt;here_a_signal(qstr);// 触发信号&#125; 由于函数重载了，这里利用函数指针指向函数地址，然后再作连接 12345678// 重载的信号与槽// ***函数指针指向重载的函数void (MySender::*myowsgnal)(QString)=&amp;MySender::here_a_signal;void (MyReceiver::*myowslot)(QString)=&amp;MyReceiver::slots_ok;// ***信号连接connect(sdr,myowsgnal,rcvr,myowslot);// 信号触发signal_generate(&quot;这是一个信号&quot;); 程序现象 12311:18:41: Starting Qtlearning01.exe...&gt;&gt;这是重载的槽函数，信号内容: &quot;这是一个信号&quot;11:18:50: Qtlearning01.exe 退出，退出代码: 0 补充-关于 QString QString 直接输出是有双引号的，如果要去掉双引号，可以按照以下途径进行转换 1// QString-&gt;QByteArray-&gt;char* 1qDebug()&lt;&lt;&quot;信号内容:&quot;&lt;&lt;content.toUtf8().data(); 此时两个输出之间会多一个空格，若要取消空格，可以使用 nospace() 方法 1qDebug().nospace()&lt;&lt;&quot;信号内容:&quot;&lt;&lt;content.toUtf8().data(); 补充-关于 Qt4 的信号与槽 使用示例 1connect(sender,SIGNAL(here_a_signal(QString)),receiver,SLOT(slot_ok(QString))); 其中用到了 SIGNAL 和 SLOT 两个宏，把信号和槽函数转为字符串，但是这个过程编译时不会检查拼写错误，故容易出错 三、信号与槽的总结 注意事项 信号发送者和接收者都是 QObject 的子类，除非使用全局槽函数或 lambda 函数 信号和槽函数返回值都是 void 信号只声明，槽函数声明并实现 槽函数是普通的成员函数，会受到 public , privace , protect 的影响 可以使用 emit 在恰当位置发送信号 使用 connect() 连接信号与槽 任何成员函数、static 函数、全局函数和 lambda 表达式都可以作为槽函数 信号槽要求信号和槽函数的参数一致。如果不一致，允许的情况是槽函数参数比信号少，但类型和顺序应当一致，这样可以在在槽函数中选择忽略信号传来的数据 拓展 一个信号可以连接多个槽函数 此时这些槽都会被调用, 但调用顺序不确定 多个信号可以连接一个槽函数 任意信号发出, 槽函数都会被调用 信号连接信号 一个信号发出会触发第二个信号 槽可以取消连接 不常见, 因为一个对象被 Delete 后, 这个对象上的槽也会被自动取消 可以使用 C++11 的 lambda 表达式","tags":["Qt"]},{"title":"我的 QT 学习记录 01","path":"/2023/10/20/我的QT学习记录01/","content":"一、写在前面 这是一个我自己的 QT 学习记录，不再进行 QT 相关介绍，只记录个人学习过程与一些笔记。 参考教程：B站千锋教育QT教程 版本1 版本2 二、下载与安装 QT 官网 是很容易找到的，但是社区版的下载地址不容易直接找到 由于高版本 QT 官方只提供了网络安装版，故下载安装 QT 维护工具 Qt Maintenance Tool 需要注册账户并登录，如图，然后下一步。 选择直接提供的 QT6.6 的选项，这样能避免后来自己选组件导致的发现缺少了编译器或者库的尴尬局面。 一路向下，等待下载安装完成 三、HelloWorld 打开新安装的 QTCreater ，创建项目 选择 Qt Widget 设置保存位置和项目名字 把构建系统从 cmake 改为 qmake 选择 QWidget，取消勾选Generate form 一直下一步，直到完成 Ctrl+B 构建项目，Ctrl+R 运行项目，此时出现一个空窗口，完成。 四、补充说明 .pro 文件是 qmake 的配置文件， Qt 可以使用 cmake 或 qmake 构建。相对而言，qmake更简洁，更方便；cmake和其他语言交互更好，更通用。 一般而言，把写的主要窗口逻辑放在Widget.cpp里面 默认生成的.pro文件介绍 12345678910111213141516171819QT += core gui # 井号是行注释greaterThan(QT_MAJOR_VERSION, 4): QT += widgets #大于Qt4版本才包含此模块CONFIG += c++17 #语言规范默认设置为 C++17# You can make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0SOURCES += \\ #源代码文件包含 main.cpp \\ widget.cppHEADERS += \\ #头文件包含 widget.h# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target 默认 main.cpp 介绍 12345678910#include &quot;widget.h&quot; //Qt一个类对应一个头文件#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv);//一个程序有且仅有一个QApplication Widget w; // 构造 Widget w.show(); // 显示 Widget return a.exec(); //进入事件循环&#125; Qt 窗口坐标系 从左向右是 x轴 增大的方向 从上到下是 y轴 增大的方向 (0,0) 是左上角起始位置 Qt 有帮助手册可以参考，程序名为Assistant….. 五、空窗口上放置控件–按钮示例以下为Widget.cpp 示例 123456789101112131415161718192021222324252627282930#include &quot;widget.h&quot;#include &lt;QPushButton&gt;Widget::Widget(QWidget *parent) //构造函数，大致理解为初始化、赋初值 : QWidget(parent)&#123; //修改窗口标题 this-&gt;setWindowTitle(&quot;第一个窗口&quot;); //设置窗口大小 this-&gt;resize(600,400); //设置为固定大小，不可拉伸 this-&gt;setFixedSize(500,500); //新建按钮-方式1 QPushButton *button= new QPushButton; //设置按钮属性 button-&gt;setText(&quot;我是按钮&quot;);//设置显示 button-&gt;move(50,100);//设置位置 button-&gt;setFixedSize(200,200); //设置按钮父对象 button-&gt;setParent(this); //新建按钮-方式2 QPushButton *btn2 =new QPushButton(&quot;第二个按钮&quot;,this); btn2-&gt;move(0,50);&#125;Widget::~Widget()//析构函数，可理解为内存回收&#123;&#125;","tags":["Qt"]},{"title":"“沣镐思享”思政研讨会-第2次","path":"/2023/10/13/“沣镐思享”思政研讨会-第2次/","content":"主题《后真相时代如何求真？》 时间 2023.10.13 开放问题 “在您看来，什么是’后真相时代’的关键特征？” “您认为在这个时代中，如何最好地验证信息的真实性？” 情境问题 “根据您将来打算从事的职业，谈一谈如何确保后真相时代您发布的信息仍然可信可靠？” “当您在社交媒体上看到一个有争议的信息时，您会采取什么行动？” 对比问题 “相比于传统媒体，社交媒体在’后真相时代’中的优势和劣势是什么？” “您认为事实核查工具（技术手段）对求真有何帮助？” 个人经验 您曾经遇到过信息误导的情况吗？您是如何应对的？” “您有哪些方法来帮助大家更好地辨别真假信息？” 展望未来 “您认为未来信息验证的方法会如何演变？” “在后真相时代中，教育领域需要做出哪些改变？” 我的准备材料[一] 后真相时代的特征定义百度百科：所谓**后真相**，是指忽视真相、不顾事实的委婉说法。是“事实胜于雄辩”的相反，即是“雄辩胜于事实”，意见重于事实，立场决定是非；人们把情感和感觉放在首位，证据、事实和真相沦为次要（甚至毫不重要）；一个人说谎，不再是为了瞒骗，而是巩固目标群众的偏见，换取共鸣与支持。 维基百科：后真相是指一些人为了自身利益，无视客观事实，盲目迎合受众的情绪与心理，使用断言、猜测、感觉等表达方式，强化、极化某种特定观点，攻讦抹黑对手，或博取眼球效应和支持率。 《纽约时报》将“后真相”定义为“情感及个人信念较客观事实更能影响舆论的情况”。 核心特征后真相 情感及个人信念相比客观事实更能影响舆论 值得注意的是 后真相时代，真相并没有被篡改，也没有被质疑，只是变得次要了，网民相比相信真相，更加相信感觉，只愿意去听、去看想听和想看的东西。客观事实的陈述，往往不及诉诸情感和煽动信仰更容易影响民意。 [二] 后真相时代舆论呈现的新特点 引自M2-1 舆论主体的转变使得后真相时代的舆论更具突发性、动态性 典型例子是 2016美国大选 主流媒体“一边倒”地支持希拉里，所有预测机构严苛地按照数据分析的程序进行大选结果预判时，希拉里的大选优势却在一瞬间就被逆转。与其说是特朗普战胜了希拉里，不如说是社会化媒体的舆论波影响了网民的认知、态度和行为，舆论的动态变化已令传统媒体无法掌控。 还有 2016英国脱欧 观点先于事实，理性讨论让位于情感诉求 例子：2016 年出现了 “罗一笑，你给我站住”引发的新闻事件，在整个事件的发展过程中舆论数次反转。···· 以戏谑和狂欢表达为主，热点议题转化速度快 以戏谑和狂欢为主的表达方式使得人们在发表言论时大多缺乏理性沟通的基础，更愿意凭借自己的主观臆断去判定新闻事实，这在很大程度上是对新闻事实的“曲解”和“重塑”。 [三] 微信谣言传播机制-传播学角度 引自M2-2一、传播路径 谣言传播符合幂律分布：80%左右会自动消解 任何一个谣言都有其制造、传播、高峰和消亡（或反复）的四个阶段，只是在本文中选取七类谣言对其转发次数的分析发现，不同类别的谣言出现转 发 峰 值 的 情 况 不 尽 相同，但每个类别的中都存在相似的情况，即只有其中20%左右的谣言会获得一个不断转发和重复出现的机会，80%的谣言会自动消解，甚至也不会再重复出现 60%的谣言会在一周内消亡 对网络谣言的活跃期进行时间统计可以得出，由于各辟谣平台和当事人的及时辟谣，60%的谣言活跃期都在7天以内，因为有近20%的谣言会反复出现，没法统计所有谣言的活跃周期，但也一定程度上说明谣言横行的一种错觉不是谣言的数量很多，而是谣言由于人们加入的社群的数量增多，而变得很容易被遇到，显得频度很高罢了。 嵌套传播：与传统社会人际网近似的圈群化传播 网络谣言在传播结构上最大的变化是圈群化传播，圈群化是和传统社会人际关系网最为接近的网络结构，是最适宜谣言传播的结构。网络谣言在一个圈子内部传播，会被信息桥结点（谣言搬运工）转发到其他圈子，出现了圈子之间的嵌套、连接进而会产生情绪共振和情感共鸣（李彪，2013），会在整个虚拟空间形成一种群体的压力，传谣的氛围至此形成. 二、传播节点 造谣者以草根账号为主 在公众账号制造的谣言中，90%以上是“个人账号”制作和传播的，即为初始信源，而在信息推送和传播的过程中，个人账号推送的信息无论在呈现方式和打开阅读的形式上与认证机构账号基本一致，这造成了很多易感人群（尤其是新媒体素养相对不高的中老年网民群体）误认为是与传统媒体一样公信力的认证账号推送的。而个人账号由于各种动机为了赚取眼球或者耸人听闻，故意造谣、传谣，而为此付出的代价成本较低. 谣言信源的唯一性 网络谣言和真实信息在传播节点上最大的差异在于网络谣言的信源追溯具有唯一性，而真实事实的信息源则相对多元，毕竟事实发生时会有很多的目击者或者亲历者，真实信息的传播是以无影灯效应而建构真实的，而网络谣言由于是主观为之，是一种“创意的真实”，信息源只有一个，与真实信息的多信源相比很容易从中被鉴别。 谣言“搬运工”：中老年群体尤其是以女性为主 谣言之所以能被传播与扩散，离不开另外一个重要的信息桥结点，即谣言的“搬运工”，将谣言从一个圈群通过转发和发表朋友圈而影响更多的“未感染者”。虽然动机不同，但根据以往的相关研究，谣言“搬运工”多以平均年龄在50岁以上的中老年女性为主（李洁，2017），这类人群具有以下特征：新媒体素养不高、对谣言的真实性鉴别力不高，但因为多扮演妈妈、奶奶、外婆等社会角色，经常转发一些有关生活常识、社会安全等相关的网络谣言。 三、传播特点 加冕与祛魅 事实让位于立场：谣言传播的逆火效应 圈群化传播使得可视化带来负效应 圈群化传播带来的延时机制 谣言传播的少数群体情绪启动效应 四、政府方面-网络辟谣的举措与路径 引自M2-2 变被动为主动：辟谣关口前置化 在网络辟谣中经常会遇到这样的难题，即谣言发布时阅读者众多，辟谣时很多人看不到，形成了传谣与辟谣的信息曝露不对称现象。随着人工智能技术的成熟，网络辟谣越来越呈现出新的发展方向。 利用大数据技术鉴别谣言信源的唯一性进行有效锁定。根据谣言传播的信息源具有唯一性的有效识别特征，通过大数据回溯技术，可以准确将网络谣言进行有效识别，进而进行传播干预。只有在谣言产生于传播初期就能够将其识别，才能将谣言的危害降至最低。 充分利用谣言的传播时滞性。网络谣言从核心地区向边缘地区、从核心人群向边缘人群的传播有1～3天的时间周期，因此生活在北上广的人们经常发现其在三四线城市的父辈传回来的谣言是几天前的。因此网络谣言需要抓住这个传播时滞期，及早切断传播路径，实现网络谣言预警的主动性。 变内容识别为圈群识别与情绪识别：为重点人群画像 要对公共账号进行认证身份的明确标示。在很多网络谣言的传播中，由于均是公号推送，很多易感人群没有区分公号主体是否被官方有效认证的能力，结果造成很多个人账号也滥竽充数。因此，需要加强公号主体对传播内容的认证标示，并将之作为一种基本识别谣言的科普性知识进行推广，虽然微博的加V认证策略一定程度上使得网络空间出现了明星围观模式，但对快速形成明星影响力和有效规范明星的言论责任都起到了不可替代的作用。 要分析谣言节点的社会网络结构。信息接收者仅通过内容很难识别谣言，而信息发布者属性和网络传播属性能显著提高信息接收者的识别率。因此需要引入更多的辟谣识别变量，这也是人工智能所具有的基本功能，强化每个节点在最活跃的几个圈群中的社会结构和社会角色，进而对在谣言链条中的角色进行有效识别。再次，构建信用分级的造谣者、传谣者和易信谣者数据库。网络谣言的治理从根本上讲是对人的治理，对人的治理要考虑针对性和精准化。按照谣言传播链条的角色和地位，可以将之分为造谣者、传谣者和易信谣者，并对之进行传播信用等级的评估，类似于征信体系。并在账号主体明显的位置上予以标识，对信用等级较低的账号进行预警，一旦用户点开其传播的信息，自动预警提示。 警惕“谣言营销”现象的蔓延。在很多谣言传播的背后是是一些营销号为了经济利益而进行造谣，甚至将“谣言营销”堂而皇之地作为一种营销伎俩。转发量高的微信可以增加粉丝，超过5万粉丝，就可以获得广告收益，一个拥有5万粉丝的微信号，一条微信的价格在1000元到2000元不等，粉丝量超过10万，微信价格可超5000元，至于坐拥50万粉丝的微信大号，一条微信的售价可卖到上万元（樊伟宏，2015）。同时，微信的转发量和阅读量也和广告费用挂钩，这就是不少公众号挖空心思造谣传谣的真正原因。 各自为战为综合治理：网络辟谣的社会化 五、媒体方面的一些西方经验 引自M2-41. 坚持核实原则事实核查新闻（fact-checking news）作为一种新的新闻样式，日渐成为辨识虚假新闻（fake news）和监督公众人物的有力手段。虽2016年美国大选将“后真相”推向了顶峰，但“多家新闻机构及时跟进事实核查，流量和合作需求翻倍，堪称该领域发展的历史性时刻。”不仅如此，近十余年，遍布五大洲50多个国家的由非专业新闻人士组成的事实核查团体，致力于核实政治家和公众人物的言论及媒体报道。（周炜乐、方师师，2017：p.33-42） 2. “透明性原则”及实践透明性原则”为比尔•科瓦齐（Bill Kovach）和汤姆•罗森斯蒂尔（Tom Rosenstiel）在《新闻的十大基本原则》一书中所倡议，受到学界、业界及公众的重视，被引入教科书和行业规范之中。“透明性原则”包括“公开的透明性”（disclosure transparency）以及“参与的透明性”（participatory transparency）两个方面，“前者指的是新闻生产者是否对新闻制作过程保持公开，包括告诉公众事实来源，向公众展示已经在报道中囊括一切有关的利益团体，而后者指的是使公众参与到新闻生产过程中来，包括允许公众对报道内容有所贡献，使用‘用户生成内容’等。”“它要求将公众纳入到新闻真实的建构中来，矫正和对抗报道者自身的主观偏见，实际上并没有否定客观性的理念和原则。”（Karlsson，2010；Hellmueller &amp; Poepsel，2013，转引自夏倩芳、王艳，2016：p.97-109）“透明性原则”强调开放和诚实，作为一项职业道德规范逐渐被专业新闻工作者所承认，是在新媒体环境下对客观性的有力推进。 [四] 杂项社交媒体的属性充分刺激了人们的需求，释放了人们的欲望，满足了人们在传统媒体时代无法实现的信息传播、意见表达以及社交需求放大了“坏的主观性”。引自M2-4 [五] 我的其他想法 成因方面除了众多论文中提及的，可能还有这些论文作者由于年龄原因认识不到的地方 曾有一段时间各地考试题型改革时，一些学科的主观题从唯一标准答案转向答案不唯一，能自圆其说即可。这个本意是好的，但是开始改革时可能由于缺乏经验和步子过大等原因，出现过一些题目：从理性上讲应该答案唯一，但实际怎么说都可以，只要闭口不提对观点不利的证据，找到支持观点的例子的情况即可。 我觉得可能这里对特定年龄(即当时正遇到改革)的一部分人的思维模式造成了一些影响，算起来最早接触也是平时刻意加强相关题目训练的一批人，近几年正不断进入社会，或许有一部分参与了新闻媒体等工作。 [六] 搜集自知乎的其他资料 来自知乎：上杉绘梨香 1所谓“后真相”，不单单只是说谎的委婉说法，而还指忽视真相、不在乎事实的谣言，以各种似是而非和断章取义的言论，把真相放在强调的先后顺序后面，最终达到弄假成真的效果。现今后真相除了媒体也深入政治，是“事实胜于雄辩”的相反，即是“雄辩胜于事实”的价值观成为社会的主流，主观意见重于客观事实，立场决定是非，不同派系的人被划入群体塑造对立；人们把情感和感觉的评论放在首位，评价证据、事实和真相沦为次要（甚至毫不重要），各种角度断章取义的解读，偏激的价值观越来越多；政治人物说谎更具巧思，不再是为了单纯瞒骗和蒙混事实，而是巩固目标群众的偏见，换取共鸣与支持。此外，主流媒体的政治偏见与信息的传递过快，民众及政治人物不再信任媒体的报导，社群媒体中人人都能成为新闻创作者，各种片面的言论难以求证，是造成后真相政治出现的部分原因。 来自知乎：乌托邦与你 12345678910111213141516171819202122后真相反映的是当今的一种典型状态，即“客观事实的陈述，往往不及诉诸情感和煽动信仰更容易影响民意”。或者说，今天的人们不再追求事实与真相，而是容易被各种情绪、情感所煽动。造成称后真相现象的原因复杂，有社会结构经济利益因素，也有媒介技术发展变化的影响，当然也与人们自身的认知、态度形成的机制相关。后真相时代所蕴含的民意的不理性不单单是当前时代所独有的，而媒介技术发展变迁所带来的社交媒体平台，使民意的不理性被摆在了台前，成了后真相现象的展台。典型的内容分享型社交媒体平台微博就是后真相现象的聚集地之一。今年男明星吴某的涉嫌性侵事件、ID拜拜啦人间自曝强奸案件引起舆论哗然，随着事件整体的明晰，用户的舆论风向千回百转，无不展现着后真相时代的理性缺失。一 后真相现象与专业媒体（一）专业媒体应该避免成为情绪化信息解读源头的情绪化信息发布源头。网络传播环境下技术使得个体发布信息的成本大大降低，各式社交媒体平台又使得公众拥有了多样的传播平台可以选择，这些都促使大众新闻的繁荣，专业媒体在信息源的掌控上逐渐失去了优势地位，很多新闻往往是事件相关的个人最先爆出，媒体再去跟进，而个人所发布的信息本身就带有强烈的主观情绪、态度，并且真假难断。同时社交媒体平台的碎片式表达模式，使得很多新闻在产生之初内容就是不完整、片面的。而一些媒体为了追逐热点，以新闻的时效性为借口，跟进发布这些片面的信息，甚至罔顾中立，公平的原则，在事件尚未明了时就大肆评论。（二）后真相时代媒体应坚持新闻专业主义，加强对信息的审查，对舆论的引导。面对信息源的多样和非专业的个人所夹带的情绪化的信息，专业媒体在跟进相关事实之前应该对相关事实进行严谨的求证，并以客观中立的态度来报道。流量时代追逐热点是一个常态，而专业媒体人更应该在追逐热点和新闻的整体真实性上做出平衡，切不可为了追逐热点片面的报道评价事件。在引导舆论方面，事件尚未明朗之时除了客观报道事件外更应指出事件尚未明了的现状，引导舆论理性看待事件。二、后真相时代与社交媒体平台（一）社交媒体平台—情绪化碎片化信息的生成传播平台。社交媒体平台由于其本身传播特点容易引起病毒式的传播，这使得一些热点事件在整体情况明朗前，片面的情绪化的信息就已经广泛传播。而出于对用户注意力的吸引的目的，很多平台也刻意用片面的刺激性的标题来吸引用户，比如各平台的热搜榜，信息推送标题往往都是带有强烈情绪暗示的。（二）社交媒体平台应加强对信息的审查，完善用户举报的功能，提供事件发生的整体进展。许多病毒式传播的信息往往是一些自媒体，别有用心之人出于利益因素而编排的。在一些事件的发生过程中，社交平台上存在一些极端的用户，对意见相左的其他用户恶语相加或集群进行网暴。作为公共话语空间的社交媒体平台有责任保持公共空间的秩序，对于煽动激化群众情绪的恶意信息应该加强审查和管制、完善信息举报审查机制，使各种合理的意见得以表达。由于网络平台信息的海量，很多被片面信息吸引而来的群众无法准确了解一些事件的全貌，平台应该运用技术手段，使相应事件的进程、相关内容聚合在一起，方便用户了解事件全貌。三、后真相时代与个人（一）借事件表达情绪观点的个人和相对匿名下的乌合之众。许多事件在整体明晰前就引发了大量的讨论，这往往是由于事件本身激起了利益相关的个体的情绪。比如ID拜拜了人间强奸案件，引起了关于女性在强奸案件中维权困难的广泛讨论。但这些问题并不是事件出现才发生的，有些问题积病久已。而另一些人在参与讨论的过程中纯粹是相对匿名状态下的情绪发泄，他们煽动对立，在网上肆意攻击谩骂意见不同的人。（二）不做情绪的奴隶，提高媒介素养关键是理性思考和开放包容的心态。后真相时代事件的整体浮出水面需要一定时间，个人在面对海量信息时要加强理性思考不妄下判断，开放包容的接受不同的声音。在理性思考的基础上表达自己的观点，和他人进行交流是个人为正确舆论形成所能贡献的力量。后真相时代表现为民意的理性缺失，却有着纷繁复杂的形成机制，改变这一现状需要个人、媒体、平台的多方发力。","tags":["哲学思辨"]},{"title":"使用Gin框架时常用的HTML模板语法示例","path":"/2023/09/20/使用Gin框架时常用的HTML模板语法示例/","content":"一、主要涉及的项目结构12345678910111213│ main.go│ └─part08 │ ├─myfunc │ usr.go │ ├─static │ └─templates └─demo01 hello.html hello2.html 二、主要文件内容 hello.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&#123;&#123;define &quot;demo01/hello.html&quot;&#125;&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML模板&lt;/title&gt; &lt;!-- &lt;script src=&quot;/s/js/jquery.min.js&quot;&gt;&lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; 一、对符号的支持：&lt;br&gt; 1.字符串：&#123;&#123;&quot;abc123汉字&quot;&#125;&#125;&lt;br&gt; 2.原始字符串：&#123;&#123;`abc123汉字`&#125;&#125; 不会转义&lt;br&gt; 3.字节类型：&#123;&#123;&#x27;a&#x27;&#125;&#125; 会转义&lt;br&gt; 4.打印：&lt;br&gt; 打印字符串&#123;&#123;print &quot;abc你好&quot;&#125;&#125;&lt;br&gt; nil类型&#123;&#123;print nil&#125;&#125;&lt;br&gt;&lt;br&gt; 二、变量&lt;br&gt; &#123;&#123;$name1 :=&quot;abc123汉字&quot;&#125;&#125;&lt;br&gt; &#123;&#123;$name1&#125;&#125;&lt;br&gt;&lt;br&gt; 三、条件&lt;br&gt; 当.condition为bool类型的时候，则为true表示执行， 当.condition为string类型的时候，则非空表示执行。&lt;br&gt; &#123;&#123;if .flag&#125;&#125; TRUE&lt;br&gt; &#123;&#123;if $.nonedatastr&#125;&#125; 后端有传入nonedatastr &#123;&#123;end&#125;&#125; &#123;&#123;else&#125;&#125; false &#123;&#123;end&#125;&#125; 四、循环体&lt;br&gt; age:&#123;&#123;.age&#125;&#125;&lt;br&gt; &#123;&#123;/*使用循环体的range， 可以遍历map和slice等*/&#125;&#125; arr:&#123;&#123;range .arr&#125;&#125; &#123;&#123;.&#125;&#125; &#123;&#123;end&#125;&#125;&lt;br&gt; &#123;&#123;/*使用索引和内容， “$”代表模板根级上下文， “$.可以用来在循环内部获取根级上下文”*/&#125;&#125; index_and_value:&lt;br&gt; &#123;&#123;range $i,$v := .arr&#125;&#125; &#123;&#123;$i&#125;&#125;:&#123;&#123;$v&#125;&#125;,&#123;&#123;$.age&#125;&#125;&lt;br&gt; &#123;&#123;else&#125;&#125; range也支持else，当被遍历的长度为0是执行else&lt;br&gt; &#123;&#123;end&#125;&#125;&lt;br&gt; 五、多个“.”与with关键字&lt;br&gt; 1.多个“.”的使用&lt;br&gt; &#123;&#123;.stu.Name&#125;&#125;,&#123;&#123;.stu.Age&#125;&#125;&lt;br&gt; &lt;!--貌似子对象里的名字也会与其他和父对象并列的变量冲突--&gt; 2.With关键字&lt;br&gt; &#123;&#123;with .stu&#125;&#125; &#123;&#123;.Name&#125;&#125;,&#123;&#123;.Age&#125;&#125;&lt;br&gt; &#123;&#123;else&#125;&#125; 暂无stu的数据 &#123;&#123;end&#125;&#125; 六、内嵌另外的模板&lt;br&gt; &#123;&#123;template &quot;demo01/hello2.html&quot;&#125;&#125; &lt;!--如果想要传递数据到内嵌的模板中，可以通过共享“.”进行传递--&gt; &#123;&#123;template &quot;demo01/hello2.html&quot; .&#125;&#125; 七、模板函数&lt;br&gt; 1.printf分隔符用空格，不是逗号；其余参照fmt&lt;br&gt; &#123;&#123;printf &quot;一个字符串：%s 一个整数：%d&quot; &quot;这是字符串&quot; &quot;19&quot;&#125;&#125;&lt;br&gt; 2.len求长度&lt;br&gt; arr长度为：&#123;&#123;len .arr&#125;&#125;&lt;br&gt; 3.管道符号“|”&lt;br&gt; &#123;&#123;&quot;this is a string&quot;|printf &quot;%s&quot;&#125;&#125;&lt;br&gt; &#123;&#123;&quot;this is a string&quot;|len&#125;&#125;&lt;br&gt; 4.括号提升优先级&lt;br&gt; &#123;&#123;printf &quot;名字:%s,国家: %s&quot; &quot;LiHua&quot; (printf &quot;%s-%s&quot; &quot;Earth&quot; &quot;China&quot;)&#125;&#125;&lt;br&gt; 5. and只要有一个为空，则整体为空;如果都不为空，则返回最后一个&lt;br&gt; &#123;&#123;and .age .nonedatastr&#125;&#125;&lt;br&gt; &#123;&#123;and .age .name&#125;&#125;&lt;br&gt; 6. or 只要有一个不为空，则返回第一个不为空的;如果都是空，则返回空&lt;br&gt; &#123;&#123;or .age .nonedatastr&#125;&#125;&lt;br&gt; &#123;&#123;or .nonedatastr .age&#125;&#125;&lt;br&gt; &#123;&#123;or .xxx .nono&#125;&#125;&lt;br&gt; 7. not用于判断返回布尔值，如果有值则返回false，没有值则返回true&lt;br&gt; &#123;&#123;not .nonedatastr&#125;&#125;&lt;br&gt; &#123;&#123;not .age&#125;&#125;&lt;br&gt; 8. index读取指定类型对应下标的值(map, slice, array, string)&lt;br&gt; &#123;&#123;index &quot;abcdefq&quot; 2&#125;&#125;&lt;br&gt; &#123;&#123;index .arr 2&#125;&#125;&lt;br&gt; 9. eq:等于 equal，返回布尔值&lt;br&gt; 10. ne:不等于 not equal，返回布尔值&lt;br&gt; 11. lt:小于 less than，返回布尔值&lt;br&gt; 12. le:小于等于 less equal，返回布尔值&lt;br&gt; 13. gt:大于 greater than，返回布尔值&lt;br&gt; 14. ge:大于等于 greater equal，返回布尔值&lt;br&gt; 示例：&#123;&#123;ge 10 9&#125;&#125;&lt;br&gt; 15. 关于时间日期&lt;br&gt; 后端直接传入未处理的时间：&#123;&#123;.time&#125;&#125;&lt;br&gt; 前端格式化时间日期：&#123;&#123;.time.Format &quot;2006-01-02 15-04-05&quot;&#125;&#125;&lt;br&gt; &lt;!--这个参照的时间有点离谱，任意改变后可能时间显示非预期--&gt; 八、自定义模板函数&lt;br&gt; 1.步骤一，先在后端定义一个函数&lt;br&gt; 2.步骤二，调用SetFuncMap方法注册函数&lt;br&gt; 3.步骤三，可以在HTML模板中使用函数 &#123;&#123;add 123 741&#125;&#125;&lt;br&gt; &lt;/body&gt;&lt;/html&gt;&#123;&#123;end&#125;&#125; hello2.html 123456789101112131415&#123;&#123;define &quot;demo01/hello2.html&quot;&#125;&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;一个新的页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;font color=&quot;red&quot;&gt;这是一个新的页面：&lt;/font&gt; &#123;&#123;.&#125;&#125; &lt;br&gt; &lt;/body&gt;&lt;/html&gt;&#123;&#123;end&#125;&#125; main.go 1234567891011121314151617181920package mainimport (\t&quot;GinLearning/part08/myfunc&quot;\t&quot;text/template&quot;\t&quot;github.com/gin-gonic/gin&quot;)func main() &#123;\tr := gin.Default()\tr.SetFuncMap(template.FuncMap&#123; //注册可用于模板的函数 &quot;add&quot;: myfunc.Diyfunc,\t&#125;)\tr.LoadHTMLGlob(&quot;part08/templates/**/*&quot;)\tr.Static(&quot;/s&quot;, &quot;part08/static&quot;)\tr.GET(&quot;/demo&quot;, myfunc.Hello08)\tr.POST(&quot;/postfile&quot;, myfunc.Hello08)\tr.Run(&quot;:8088&quot;)&#125; usr.go 1234567891011121314151617181920212223242526272829303132333435package myfuncimport (\t&quot;time&quot;\t&quot;github.com/gin-gonic/gin&quot;)type student struct &#123;\tName string\tAge int&#125;func Hello08(c *gin.Context) &#123;\tage := 19\tarr := []int&#123;12, 23, 45&#125;\tflag1 := true\tstu := student&#123; Name: &quot;小明&quot;, Age: 10,\t&#125;\tnow_time := time.Now()\tmap_data := map[string]interface&#123;&#125;&#123; &quot;age&quot;: age, &quot;arr&quot;: arr, &quot;flag&quot;: flag1, &quot;stu&quot;: stu, &quot;time&quot;: now_time,\t&#125;\tc.HTML(200, &quot;demo01/hello.html&quot;, map_data)&#125;func Diyfunc(a, b int) int &#123;\treturn a + b&#125;","tags":["Golang"]},{"title":"Hello World","path":"/2022/11/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":["Test"]}]